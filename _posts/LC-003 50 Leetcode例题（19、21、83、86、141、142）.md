# Leetcode 3
***
## 19 Remove Nth Node From End of List
**[Medium]**
Given a linked list, remove the n-th node from the end of list and return its head.

**Example**:
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.

Note:
Given n will always be valid.
Follow up:
Could you do this in one pass?
* C Code
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
    struct ListNode* first=head;
    struct ListNode* second=head;
    while(first!=NULL){
        first=first->next;
        if(n--<0){
            second=second->next;
        }
    }
    if(n==0) head=head->next;
    else second->next=second->next->next;
    return head;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190414133548580.gif)
* Python Code
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        fast = slow = head
        for _ in range(n):
            fast = fast.next
        if not fast:
            return head.next
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return head
```
***
## 21 Merge Two Sorted Lists
**[Easy]**
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Example**:
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

* C Code
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
#recursively
struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
    if(l1==NULL) return l2;
    if(l2==NULL) return l1;
    if(l1->val <= l2->val){
        l1->next=mergeTwoLists(l1->next,l2);
        return l1;
    }else{
        l2->next=mergeTwoLists(l1,l2->next);
        return l2;
    }
}
```
* Python Code
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# iteratively
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        merge=cur=ListNode(0);
        while l1 and l2:
            if l1.val < l2.val:
                cur.next=l1
                l1=l1.next
            else:
                cur.next=l2
                l2=l2.next
            cur=cur.next
        cur.next=l1 or l2
        return merge.next
```
***
## 83 Remove Duplicates from Sorted List
**[Easy]**
Given a sorted linked list, delete all duplicates such that each element appear only once.

**Example 1**:
Input: 1->1->2
Output: 1->2

**Example 2**:
Input: 1->1->2->3->3
Output: 1->2->3

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* deleteDuplicates(struct ListNode* head) {
    if(head){
        struct ListNode *p=head;
        while(p->next){
            if(p->val != p->next->val){
                p=p->next;
            }else{
                struct ListNode* temp=p->next;
                p->next=p->next->next;
                free(temp);
            }
        }
    }
    return head;
}
```
* Python Code
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        prev_node = head
        if not prev_node: return None
        node = prev_node.next
        while node:
            if node.val == prev_node.val: prev_node.next = node.next
            else: prev_node = node
            node = node.next
        return head
```
***
## 86 Partition List
**[Medium]**
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.

**Example**:
Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5
* C Code
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* partition(struct ListNode* head, int x) {
    struct ListNode left,right;
    struct ListNode *left_cursor,*right_cursor;

    left_cursor = &left;
    right_cursor = &right;

    while(head){
        if(head->val < x){
            left_cursor->next = head;
            left_cursor = left_cursor->next;
        }else{
            right_cursor->next = head;
            right_cursor = right_cursor->next;
        }
        head = head->next;
    }

    right_cursor->next = NULL;
    left_cursor->next = right.next;

    return left.next;

}
```
* Python Code
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
        """
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """
        def partition(self, head, x):
            h1 = l1 = ListNode(0)
            h2 = l2 = ListNode(0)
            while head:
                if head.val < x:
                    l1.next = head
                    l1 = l1.next
                else:
                    l2.next = head
                    l2 = l2.next
                head = head.next
            l2.next = None
            l1.next = h2.next
            return h1.next
```
***
## 141 Linked List Cycle
**[Easy]**
Given a linked list, determine if it has a cycle in it.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

**Example 1**:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328084748979.png)

**Example 2**:
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328084803275.png)

**Example 3**:
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328084812219.png)
* C Code:
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    struct ListNode *A=head, *B=head;//A goes faster while B goes slower
    while(A && B && A->next){
        A=A->next->next;
        B=B->next;
        if(A==B){
            return true;
        }
    }
    return false;
}
```
* Python Code:
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        fast=head
        slow=head
        while fast and fast.next:
            fast=fast.next.next
            slow=slow.next
            if fast is slow:
                return True
        return False
```
***
## 142 Linked List Cycle II
**[Medium]**
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Note: Do not modify the linked list.

**Example 1**:
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328085614713.png)
**Example 2**:
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328085625922.png)
**Example 3**:
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328085640469.png)
* C Code
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *fast=head, *slow=head;
    while(fast && fast->next){
        fast=fast->next->next;
        slow=slow->next;
        if(fast==slow){
            fast=head;
            while(fast!=slow){
                fast=fast->next;
                slow=slow->next;
            }
            return slow;
        }
    }
    return NULL;
}
```
* Python Code
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        fast=head
        slow=head
        while fast and fast.next:
            fast=fast.next.next
            slow=slow.next
            if fast is slow:
                fast=head
                while fast is not slow:
                    fast=fast.next
                    slow=slow.next
                return fast
```
