---
layout:     post                    # 使用的布局（不需要改）
title:      正态总体参数置信区间               # 标题 
subtitle:    #副标题
date:       2019-05-11             # 时间
author:     WZY                      # 作者
header-img: img/graph.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
mathjax: true
tags:                               #标签
    - stats
--- 

# 写个代码帮我做数理统计作业系列

写这一篇的起因是数理统计作业太难算了，算出来也不知道自己算得对不对，不如写点儿代码，让计算机帮忙检验自己的答案。当然啦，我的代码选择的是Python，
毕竟有scipy.stats这么好用的统计学库，何乐而不为。

## 1 枢轴变量法
枢轴变量法的基本要点，就是在点估计的基础上去构造它的置信区间，而一般构造置信区间的步骤大概就是这样：

1）找待估参数的一个良好点估计T(X)

2）构造一个T(X)和待估参数的函数（枢轴变量）

3）选取常数a、b使得$$P_\theta(a\geq\psi(T,\theta)\geq b)=1-\alpha$$

这地方需要注意几点：首先第一步中枢轴量通常是在充分统计量或点估计的函数中寻找的。另外枢轴量必须满足表达式与待估参数有关但分布于待估参数无关
（枢轴量在形式上依赖于样本和待估参数，是样本与待估参数的函数，不含其它未知数）

## 2 正态总体参数的置信区间

由于在数理统计中经常用到，这里归纳一下正态总体参数的置信区间：

![](https://github.com/Tinky2013/My-class-expansion/raw/master/img/066-7485-1.JPG)

## 3 代码实现

好了，用了这个Python代码，以后直接可以进行函数调用,输出待求的估计区间，判断自己做的题对不对了（笑哭）

```Python
from scipy import stats
import math

#A.单正态总体参数的置信区间
#A1.方差已知求均值的置信区间
#该函数需传入样本、总体方差、alpha
def sN_mu_sigk(sample,sigma2,alpha):
    X=sum(sample)/len(sample)
    u=stats.norm.isf(alpha/2)
    sigma=math.sqrt(sigma2)
    c=X-u*sigma/math.sqrt(len(sample))
    d=X+u*sigma/math.sqrt(len(sample))
    print("[{:.5f},{:.5f}]".format(c,d))

#A2.方差未知求均值的置信区间
#该函数需传入样本大小、样本均值、样本方差、alpha
def sN_mu_siguk(n,X,Var,alpha):
    t=stats.t.isf(alpha/2,n-1)
    c=X-sqrt(Var)*t/math.sqrt(n)
    d=X+sqrt(Var)*t/math.sqrt(n)
    print("[{:.5f},{:.5f}]".format(c,d))

#A3.均值已知求方差的置信区间
#该函数需传入样本、均值、alpha
def sN_sig_muk(sample,mu,alpha):
    n=len(sample)
    chi2_1=stats.chi2.isf(alpha/2,n)
    chi2_2=stats.chi2.isf(1-alpha/2,n)
    Smu2=(sum([(i-mu)**2 for i in sample])/n)
    c=n*Smu2/chi2_1
    d=n*Smu2/chi2_2
    print("[{:.5f},{:.5f}]".format(c,d))

#A4.均值未知求方差的置信区间
#该函数需传入样本大小、样本方差、alpha
def sN_sig_muuk(n,Var,alpha):
    chi2_1=stats.chi2.isf(alpha/2,n-1)
    chi2_2=stats.chi2.isf(1-alpha/2,n-1)
    c=(n-1)*Var/chi2_1
    d=(n-1)*Var/chi2_2
    print("[{:.5f},{:.5f}]".format(c,d))


#B.双正太总体参数均值差置信区间
#B2.方程未知但方差相等
#传入两个样本数组和alpha
def dN_mugap_sigukeq1(sample_x,sample_y,alpha):
    m=len(sample_x)
    n=len(sample_y)
    X=sum(sample_x)/len(sample_x)
    Y=sum(sample_y)/len(sample_y)
    t=stats.t.isf(alpha/2, m+n-2) 
    Sw2=(sum([(i-X)**2 for i in sample_x])+sum([(j-Y)**2 for j in sample_y]))/(m+n-2)
    Sw=math.sqrt(Sw2)
    c=Y-X-t*Sw*math.sqrt((m+n)/(m*n))
    d=Y-X+t*Sw*math.sqrt((m+n)/(m*n))
    print("[{:.5f},{:.5f}]".format(c,d))
#传入两个样本的容量、均值、方差以及alpha
def dN_mugap_sigukeq2(m,n,X,Y,Var1,Var2,alpha):
    t=stats.t.isf(alpha/2,m+n-2)
    Sw2=((m-1)*Var1+(n-1)*Var2)/(m+n-2)
    Sw=math.sqrt(Sw2)
    c=Y-X-t*Sw*math.sqrt(1/m+1/n)
    d=Y-X+t*Sw*math.sqrt(1/m+1/n)
    print("[{:.5f},{:.5f}]".format(c,d))

#B3.方差未知但利用大样本性质
#传入两个样本的容量、均值、方差以及alpha
def dN_mugap_sigukv(m,n,X,Y,Var1,Var2,alpha):
    u=stats.norm.isf(alpha/2)
    c=Y-X-u*math.sqrt(Var1/m+Var2/n)
    d=Y-X+u*math.sqrt(Var1/m+Var2/n)
    print("[{:.5f},{:.5f}]".format(c,d))


#C.双正太总体参数均值差置信区间
#C2.均值未知
#掺入两个样本的容量、方差以及alpha
def dN_sigpr_muuk(m,n,Var1,Var2,alpha):
    f1=stats.f.isf(alpha/2,m-1,n-1)
    f2=stats.f.isf(1-alpha/2,m-1,n-1)
    c=Var1/(Var2*f1)
    d=Var1/(Var2*f2)
    print("[{:.5f},{:.5f}]".format(c,d))
```
